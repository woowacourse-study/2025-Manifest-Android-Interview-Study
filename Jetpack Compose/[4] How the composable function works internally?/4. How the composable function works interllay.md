# Compiler Transformation

- `@Composable` 어노테이션을 함수에 추가하면, 해당 함수를 코틀린의 표준 함수처럼 취급하지 않는다.
- 대신 **Compose Compiler Plugin**이 컴포즈의 반응형 시스템을 활성화하기 위해 함수에 추가적인 파라미터와 로직을 주입한다.
- 숨겨진 `Composer` 객체를 통해 UI 상태 변경 시 컴포지션을 추적하고 리컴포지션을 제어한다.

```kotlin
@Composable
fun MyComposable() {
		Text("Hello, Compose!")
}
```

- 위 함수는 상태 관리를 위해 `Composer` 객체와 메타데이터를 포함한 버전으로 변환된다.

# Composition & Recomposition

- `Compose Runtime`은 컴포저블 함수의 생명주기를 관리한다.
- 컴포즈 단계 중 컴포지션 단계에서 런타임이 컴포저블 함수를 실행하고 UI 트리를 구성한다.
- UI 트리는 슬롯 테이블이라는 자료 구조에 저장되어 있으며 효율적인 관리와 UI 갱신을 돕는다.
- 상태가 변경되면 리컴포지션이 실행된다.
- UI 트리를 재생성하는 대신 슬롯 테이블을 통해 UI의 갱신이 필요한 부분을 결정하고 컴포저블 함수를 재실행한다.

## Slot Table(Gap Buffer)을 선택한 이유

- 조회, 이동, 삽입, 삭제는 모두 상수 시간 O(1)이 소요된다.
- `Gap` , 즉 커서를 이동시키는 것은 O(n)이 소요된다.
- UI 구조가 변경될 경우 커서를 이동시켜야 하는데, 이 경우는 값(상태)의 변경에 비해 발생 빈도수가 적다.
- UI 구조가 변경될 때 큰 단위로 변경되기 때문에 적절한 트레이드 오프이다.
